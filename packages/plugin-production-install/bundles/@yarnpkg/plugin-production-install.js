/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-production-install",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={558:(e,t,r)=>{r.r(t),r.d(t,{default:()=>g});var o=r(688),s=r(747),i=r.n(s),a=r(966),n=r(594),c=r(318),p=r(42);async function l(e,t,r){return o.xfs.copyFilePromise(o.ppath.join(e,r),o.ppath.join(t,r))}async function h(e,t,r,s=[]){return async function e(t,r,s=[]){if(!(await o.xfs.lstatPromise(t)).isDirectory())throw new Error("src not a folder");{await o.xfs.existsPromise(r)||await o.xfs.mkdirpPromise(r);const a=await o.xfs.readdirPromise(t);for(const n of a){const a=o.ppath.join(t,n),c=o.ppath.join(r,n);function i(){for(const e of s)if(a.endsWith(e))return!0;return!1}i()||((await o.xfs.lstatPromise(a)).isDirectory()?await e(a,c,s):await o.xfs.copyFilePromise(a,c))}}}(o.ppath.join(e,r),o.ppath.join(t,r),s)}class u{constructor({multiFetcher:e,project:t,workspace:r,cache:o,outDirectoryPath:s,outConfiguration:i}){this.multiFetcher=e,this.project=t,this.workspace=r,this.cache=o,this.outDirectoryPath=s,this.outConfiguration=i}supports(e,t){return this.multiFetcher.supports(e,t)}getLocalPath(e,t){return e.reference.startsWith(a.WorkspaceResolver.protocol)&&e.reference!==a.WorkspaceResolver.protocol+"."?null:this.multiFetcher.getLocalPath(e,t)}async fetch(e,t){const r=t.checksums.get(e.locatorHash)||null;if(e.reference.startsWith(a.WorkspaceResolver.protocol)&&e.reference!==a.WorkspaceResolver.protocol+"."){const[o,s,i]=await t.cache.fetchPackageFromCache(e,r,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,a.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be packed from disk."),loader:async()=>this.packWorkspace(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:s,prefixPath:a.structUtils.getIdentVendorPath(e),checksum:i}}if(e.reference.startsWith("npm:")){const s=this.cache.getLocatorPath(e,r),n=t.cache.getLocatorPath(e,r);if(s&&await o.xfs.existsPromise(s)&&n&&!await o.xfs.existsPromise(n))try{i().linkSync(o.npath.fromPortablePath(s),o.npath.fromPortablePath(n))}catch(e){await o.xfs.existsPromise(n)||t.report.reportError(a.MessageName.FETCH_FAILED,e)}}return this.multiFetcher.fetch(e,t)}async packWorkspace(e,{report:t}){const r=this.project.getWorkspaceByLocator(e);if(await c.packUtils.hasPackScripts(r))try{const e=await a.Cache.find(r.project.configuration,{immutable:!0,check:!1});await r.project.install({report:t,cache:e})}catch(e){await r.project.resolveEverything({lockfileOnly:!0,report:t})}let o;return await c.packUtils.prepareForPack(r,{report:t},async()=>{t.reportJson({base:r.cwd});const e=await c.packUtils.genPackList(r);for(const r of e)t.reportInfo(null,r),t.reportJson({location:r});const s=await c.packUtils.genPackStream(r,e);o=await a.miscUtils.bufferStream(s)}),await a.tgzUtils.convertToZip(o,{stripComponents:1,prefixPath:a.structUtils.getIdentVendorPath(e)})}}class d{constructor({resolver:e,project:t}){this.resolver=e,this.project=t}supportsDescriptor(e,t){return this.resolver.supportsDescriptor(e,t)}supportsLocator(e,t){return this.resolver.supportsLocator(e,t)}shouldPersistResolution(e,t){return!e.reference.startsWith(a.WorkspaceResolver.protocol)&&this.resolver.shouldPersistResolution(e,t)}bindDescriptor(e,t,r){return this.resolver.bindDescriptor(e,t,r)}getResolutionDependencies(e,t){return this.resolver.getResolutionDependencies(e,t)}async getCandidates(e,t,r){if(e.range.startsWith(a.WorkspaceResolver.protocol)&&e.range!==a.WorkspaceResolver.protocol+"."){return[this.project.getWorkspaceByDescriptor(e).anchoredLocator]}return this.resolver.getCandidates(e,t,r)}async resolve(e,t){if(e.reference.startsWith(a.WorkspaceResolver.protocol)&&e.reference!==a.WorkspaceResolver.protocol+"."){let t=this.project.getWorkspaceByLocator(e);return{...e,version:t.manifest.version||"0.0.0",languageName:"unknown",linkType:a.LinkType.SOFT,dependencies:new Map([...t.manifest.dependencies,...t.manifest.devDependencies]),peerDependencies:new Map([...t.manifest.peerDependencies]),dependenciesMeta:t.manifest.dependenciesMeta,peerDependenciesMeta:t.manifest.peerDependenciesMeta,bin:t.manifest.bin}}return this.resolver.resolve(e,t)}}var f=function(e,t,r,o){var s,i=arguments.length,a=i<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,r,o);else for(var n=e.length-1;n>=0;n--)(s=e[n])&&(a=(i<3?s(a):i>3?s(t,r,a):s(t,r))||a);return i>3&&a&&Object.defineProperty(t,r,a),a};class m extends p.Command{constructor(){super(...arguments),this.json=!1,this.silent=!1}async execute(){const e=await a.Configuration.find(this.context.cwd,this.context.plugins),{project:t,workspace:r}=await a.Project.find(e,this.context.cwd);if(!r)throw new n.WorkspaceRequiredError(t.cwd,this.context.cwd);const s=await a.Cache.find(e,{immutable:!0,check:!1}),i=t.topLevelWorkspace.cwd,c=o.ppath.isAbsolute(this.outDirectory)?this.outDirectory:o.ppath.join(r.cwd,this.outDirectory);return(await a.StreamReport.start({configuration:e,json:this.json,stdout:this.context.stdout,includeLogs:!0},async p=>{await p.startTimerPromise("Setting up production directory",async()=>{await o.xfs.mkdirpPromise(c),await l(i,c,e.get("lockfileFilename")),await l(i,c,e.get("rcFilename")),await l(r.cwd,c,(0,o.toFilename)("package.json"));const t=[];e.get("bstatePath")&&t.push(e.get("bstatePath")),e.get("installStatePath")&&t.push(e.get("installStatePath")),e.get("cacheFolder")&&t.push(e.get("cacheFolder")),e.get("pnpUnpluggedFolder")&&t.push(e.get("pnpUnpluggedFolder")),e.get("deferredVersionFolder")&&t.push(e.get("deferredVersionFolder")),await h(i,c,".yarn",t)}),await p.startTimerPromise("Modifying to contain only production dependencies",async()=>{const e=o.ppath.join(c,(0,o.toFilename)("package.json")),t=await o.xfs.readJsonPromise(e);t.devDependencies&&delete t.devDependencies,await o.xfs.writeJsonPromise(e,t)}),await p.startTimerPromise("Installing production version",async()=>{const o=await a.Configuration.find(c,this.context.plugins),{project:i,workspace:l}=await a.Project.find(o,c);if(!l)throw new n.WorkspaceRequiredError(t.cwd,this.context.cwd);const h=await a.Cache.find(o,{immutable:!1,check:!1}),f=e.makeFetcher(),m=e.makeResolver(),g=new d({project:t,resolver:m}),w=new u({cache:s,multiFetcher:f,workspace:r,project:t,outConfiguration:o,outDirectoryPath:c});await i.install({cache:h,report:p,immutable:!1,fetcher:w,resolver:g})})})).exitCode()}}m.usage=p.Command.Usage({description:"INSTALL!",details:"prod only install",examples:[["Install the project with only prod dependencies","$0 prod-install"]]}),f([p.Command.String()],m.prototype,"outDirectory",void 0),f([p.Command.Boolean("--json")],m.prototype,"json",void 0),f([p.Command.Boolean("--silent",{hidden:!0})],m.prototype,"silent",void 0),f([p.Command.Path("prod-install")],m.prototype,"execute",null);const g={commands:[m]}},594:e=>{e.exports=require("@yarnpkg/cli")},966:e=>{e.exports=require("@yarnpkg/core")},688:e=>{e.exports=require("@yarnpkg/fslib")},318:e=>{e.exports=require("@yarnpkg/plugin-pack")},42:e=>{e.exports=require("clipanion")},747:e=>{e.exports=require("fs")}},t={};function r(o){if(t[o])return t[o].exports;var s=t[o]={exports:{}};return e[o](s,s.exports,r),s.exports}return r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r(558)})();
return plugin;
}
};